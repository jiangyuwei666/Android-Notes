# 整理的面试题对应的答案
## OS
1. 
    * 进程是系统资源调度和分配的基本单位
    * 线程是进程的子任务，是cpu调度和分配的基本单位
    * 一个进程可以包含多个线程，线程依赖进程存在，并共享进程的内存
2. 
    * 共享变量(共享内存)
    * 消息队列
3.  * 互斥锁
    * 事件(条件condition)
    * 信号量
## python
1. hash表
2. 返回嵌套的
3. 
    * print
        
        python2中print是关键字，python3中是方法
        
    * 编码
        
        python2中使用的是asscii
        python3中使用的是UTF-8
        
    * True和False
        
        True 和 False 在 Python2 中是两个全局变量（名字）默认True的值是1，False的值是2
        ```
        True = 'asd'
        False = True
        ```
    * 新式类旧式类
    * 可迭代对象

        比如range()函数，pyton2中返回一个list,而python3中返回一个迭代器
    * 类型标注
    * async/await
    * 字符串

        python2中字符串分为str和unicode
        对应python3中的byte和str
4. [参考](https://github.com/Liuchang0812/slides/blob/master/pycon2015cn/README.md)

5. 一个比较的值，一个比较的地址
6. 可以使局部变量在函数外被访问，比如以下例子
    ```python
    def print_msg():
    # print_msg 是外围函数
    msg = "zen of python"
    def printer():
        # printer 是嵌套函数
        print(msg)
    return printer

    another = print_msg()
    # 输出 zen of python
    another()
    ```
    一般来说，在函数执行完成过后其内部变量是不再可用的，但是现在继续调用`another()`就可以继续访问
    
    闭包的本质是一个函数，它有两部分组成`printer()`函数和变量`msg`，闭包使得这些变量值始终保存在内存当中

    那么为什么要使用？

    闭包避免了全局变量，闭包允许将函数与其所操作的某些数据关联起来
    举例装饰器。比如说我们要给一个函数添加一些功能，以前能想到的就是利用类的继承，现在可以使用装饰器来实现。比如说一个算法，这也是我前不久刚使用过的，我在比较各种排序的效率的时候，使用装饰器来获取算法运行时间
7. os与sys模块的官方解释如下：

    os:这个模块提供了一种方便的使用操作系统函数的方法。

    sys:这个模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。

    总结:os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。
8. xrange返回的是一个生成器，而range返回的是迭代器

## 网络篇
1. 七层/五层
![OSI模型图](http://ww1.sinaimg.cn/large/006BhB5Oly1g1gk5agjc2j30fe0bkac4.jpg)
    * 数据链路层：ARP,RARP
    * 网络层： IP,ICMP,IGMP
    * 传输层：TCP ,UDP,UGP
    * 应用层：Telnet,FTP,SMTP,SNMP.
2. 三次握手、四次挥手（结合实际情况）
3. 区别
    * UDP无连接，TCP是基于链接（单次传输），所以TCP是流模式，UDP是数据报模式
    * TCP要求系统资源较多，UDP较少
    * TCP保证数据正确性，UDP可能丢包、TCP保证数据顺序，UDP不保证（可靠传输） 
4. Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

    端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

    资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

    开销：Https通信需要证书，而证书一般需要向认证机构购买； 
    　 
    Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。
5. 为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。
    客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。
1. 当你需要在一个购物网站输入账号以及密码时时，含有你的账号与密码信息的数据会被发送到服务器，在发送的过程中，数据会有两种加密形式——共享密钥加密和公开密钥加密。 
共享密钥加密可以这样理解，服务器为了使数据传输更安全，送给你一把钥匙，这把钥匙可以将数据锁在一个盒子里，当然也可以打开已经锁上的盒子。当数据送至服务器时，服务器会用同样的钥匙打开盒子。这种方法的坏处是，一旦贼人得到钥匙，便可以打开已经锁上的盒子。而公开密钥则避免了这种情况。 
公开密钥加密会使用两把钥匙，服务器会发送给你一把只能锁上盒子却不能打开盒子的钥匙，而服务器自己会留一把可以打开盒子的钥匙，这样就避免了钥匙在中途被其他人抢走风险。当服务器发回响应时会用同样的方式，只不过留有可以打开盒子钥匙的人变成了你。
1. 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；
服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。
Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。
1. 什么是拥塞？

    在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。
    
    拥塞控制？

    防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。

    拥塞处理：
    * 慢启动：
    * 快重传
    * 快恢复
1. 


## 框架篇
1. Web服务器网关接口，WSGI相当于是Web服务器和Python应用程序之间的桥梁
1. 关于web服务器和web框架（web应用）：
    ```
    web服务器即用来接受客户端请求，建立连接，转发响应的程序
    web框架是用来处理一些业务逻辑，也就是制造响应内容的部分（查询数据库）

    而Nginx就是web服务器，Django就是web框架
    ```
    WSGI、uwsgi和uWSGI:
    ```
    WSGI:只要Web服务器和Web框架都遵循这个协议，他们就能够搭配（参考问题1）
    uWSGI:uWSGI就是一个实现了WSGI和uwsgi协议的web服务器
    ```
    Nginx：
    ```
    反向代理服务器：
    uWSGI+Django其实已经够了。但是当用户量大了过后，使用分布式，由Nginx来分配客户端与哪一台服务器连接。
    ```
    nginx 和 uWISG 服务器之间如何配合工作的？
    ```
    首先浏览器发起 http 请求到 Nginx 服务器，Nginx 根据接收到请求包，进行 url 分析，判断访问的 资源类型，如果是静态资源，直接读取静态资源返回给浏览器，如果请求的是动态资源就转交给 uwsgi 服务器，uWSGI 服务器根据自身的 uwsgi 和 WSGI 协议，找到对应的 Django 框架，Django 框架下的 应用进行逻辑处理后，将返回值发送到 uWSGI 服务器，然后 uWSGI 服务器再返回给 Nginx，最后 Nginx 将返回值返回给浏览器进行渲染显示给用户。
    ```

2. 客户端发送请求->WSGI服务器或者是模块->中间件(process_request)->路由匹配找到视图函数->执行process_view->执行视图函数->取模版取数据并渲染->通过中间件->wsgi->再返回给用户
3. 
4.  * 一套后台，不仅仅用于PC端，可以用于APP，PAD等多端
    * 前端后端分离，提高开发效率
    * 降低耦合
5. 其实不用rest_framework只使用django也能实现前后端分离，提供API接口。但是使用rest_framework的话，它的内部提供了更多的组件包括序列化（对queryset进行json，请求的数据的验证）、解析器、分页拉。。。
6.  * 轻量，直接通过HTTP协议
    * 面向资源
    * 客户端根据不同的请求通过不同的方法（GET、PUT、DELETE）对服务器资源进行操作
    * 数据描述简单，一般通过JSON、xml做数据通信
## 数据库
1. 将一组sql语句放在一起，要执行就全执行，要不就全不执行；原子性、持久性、隔离性、一致性
2. 将类和对象转换成sql语句
### Redis
1. 基于内存的高性能key-value数据库