# OS
## 第一章 操作系统引论
### 1.3 操作系统基本特征
操作系统的基本特征：
* 并发
* 共享
* 虚拟
* 异步性
#### 1.3.1 并发
并发指两个或多个事件在 **同一时间段** 发生。（区分并行：在同一时间点有两个或多个事件发生）

单处理机情况下，在多道程序处理时，宏观上是并发执行，但是微观上是交替处理执行的。（所以比如4个程序并发，每个执行一分钟，实际需要4分钟。）

因此引入进程（在操作系统中能独立运行的并作为资源分配的基本单位）

#### 1.3.2 共享
共享分为两种：
1. 互斥共享（如打印机、音频设备放音乐等）
2. 同时访问（同时访问同一个文件）

并发和共享是操作系统的两个最基本的特征。二者是相互依存缺一不可。

#### 1.3.3 虚拟
通过某种技术把一个物理实体变为若干个逻辑上的对应物的功能称为虚拟（虚拟机、虚拟内存、虚拟外部设备）

某种技术指：时分复用（处理机利用为用户服务的空闲时间去为另一用户服务）和空分复用（内存利用空闲的空间区域存放和运行其他多道程序）

#### 1.3.4 异步性
指进程的执行顺序和执行时间的不确定性。

### 1.4 操作系统的主要功能
操作系统的主要功能：
* 处理机管理
* 存储器管理
* 设备管理
* 文件管理
* 用户接口

#### 1.4.1 处理机管理
处理机的分配和运行都是以进程为单位，所以处理机的管理也就是对进程的管理。
* 进程控制

    创建和撤销进程
* 进程同步

    多个进程同时执行时应该有的规矩两种方式
    * 互斥方式
    * 同步方式
* 进程通信
* 进程调度

    包括作业调度和进程调度
    * 作业调度（从外存调入内存）：从后备的作业队列中按照一定的算法选择若干个作业，为他们分配资源，内存空间，将这些作业调入内存后，分别为他们建立进程，是他们都然后将他们插入就绪进程队列中
    * 进程调度（从进程就绪队列选一个分配处理机）：从就绪进程队列根据一定的算法选取一个进程，将处理机分配给他。

#### 1.4.2 存储器管理
为多道程序运行提供环境
* 内存分配

    分配空间、提高利用率、允许动态申请
    * 静态分配

        内存空间时再作业装入后就已经确定，不能再动态增加
    * 动态分配

        允许作业再运行过程中申请附加的内存空间

    
* 内存保护

    * 每道用户程序都只在自己分配的内存空间中运行，互不干扰
    * 绝不允许用户程序访问操作系统的程序和数据
    * 寄存器
* 地址映射

    因为程序中的地址都是从“0”开始，而内存中的地址肯定不是。

    程序中的地址称为 **逻辑地址** 或者 **相对地址**。

    而内存中单元的地址称为 **物理地址**。

    进程装入内存后要由逻辑地址到物理地址进行变换，这就是映射的过程。
* 内存扩充

    不是从物理角度扩大内存的容量。借助虚拟存储技术，从逻辑上扩充，有如下两种方式
    * 请求调入功能

        代码一部分一部分的进入
    * 置换功能

        将内存中暂时用不上的换出来

#### 1.4.3 设备管理功能
设备管理的主要任务：
* 完成用户的I/O请求
* 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用
因此设备管理应该有如下功能：
* 缓冲管理

    管理CPU和I/O之间的缓冲（因为CPU和I/O速度不匹配，用来提高CPU的利用率）
* 设备分配

    根据用户的I/O请求、系统现有的资源情况分配所需的设备。
* 设备处理

    实现CPU和设备控制器之间的通信。
#### 1.4.4 文件管理功能
对用户文件、系统文件进行管理以方便用户使用，并保证文件的安全性。
* 文件存储空间的管理


* 目录管理

    为每一个文件建立一个目录项
* 文件的读/写管理和保护

    根据用户请求从外存读取数据，或写入数据到外存

    防止系统文件被非法调用
#### 1.4.5 用户接口
* 用户接口
* 程序接口
### 1.5 操作系统的结构设计
* 软件工程的基本概念
* 传统操作系统结构
* 维内核OS结构
## 第二章 进程的描述与控制
### 2.1 前驱图和程序执行
#### 2.1.1 前驱图
有向无循环。
#### 2.1.2 程序顺序执行
特征：
* 顺序性
* 封闭性（封闭环境，不受外界影响，只有本程序能改变它）
* 可再现性（只要环境和初始状态相同，结果都相同）  
#### 2.1.3 程序并发执行
* 程序的并发执行

    并发执行的前驱图
* 特征:
    * 间断性：“执行——暂停——执行”（他在系鞋带，我要等他）
    * 失去封闭性：很多个程序共用一个环境和各种资源，就会相互影响
    * 不可再现性：因为失去了封闭性
### 2.2 进程的描述
#### 2.2.1 进程的定义和特征
* 定义
     
    操作系统中一种专门的数据结构（用于使并发的每个程序都能独立运行），称为进程控制块（PCB）
    
    系统利用PCB来控制和管理进程

    由程序段、相关的数据段和PCB就构成了 **进程实体** ，即进程

    所谓创建或撤销进程，实质上创建或撤销 **进程实体** 中的PCB

    定义如下：
    1. 进程是程序的 **一次执行**
    2. 进程是一段程序及其数据在处理机上顺序执行的所发生的 **活动**
    3. 进程是具有独立功能的程序在一个数据集合上运行的 **过程** ，是系统资源分配和调度的独立单位

    *进程是进程实体的运行过程，是资源分配和调度的独立单位*
* 特征

    * 动态性
    * 并发性
    * 独立性
    * 异步性
    * 结构性
#### 进程的基本状态及转换
* 三种基本状态
    
    * 就绪状态（Ready）:准备好运行，只差CPU的分配。多个就绪状态的进程组成就绪队列
    * 执行状态（Running）:指进程已经分配到CPU正在执行。单处理机系统中只能有一个进程处于执行状态，多处理机系统允许多个进程处于执行状态
    * 阻塞状态（Blocked）:正在执行的进程由于发生了某些事情暂时无法执行的状态。系统会将处理机分配给另一个 **就绪进程** 。而阻塞的进程就组成阻塞队列。

* 三种状态的基本转换

    ![状态转换图](http://ww1.sinaimg.cn/large/006BhB5Oly1fy8pnm6ld1j309o08iaaa.jpg)

* 创建状态和终止状态
    
    除去上面的三种状态，新引入的状态
    * 创建状态：进程刚建立，还未进入就绪队列

        确保进程的完整性。
        
        因为进程创建的过程很复杂，如果进程没能被成功创建的话，就不能让它插入到就绪队列中，所以引入创建状态。
    * 终止状态：

        当一个进程已（正常或异常）结束，暂时留着，以便其他进程收集该进程的信息
    
    ![五种状态的转换](http://ww1.sinaimg.cn/large/006BhB5Ogy1fy8qhe8342j30kd0czmxt.jpg)
#### 2.2.3 挂起操作和进程状态的转换
* 挂起操作的引入
    1. 终端用户的需要。用户发现自己的程序运行期间有什么问题，就可以暂停程序运行
    2. 父进程的请求。父进程要考查和修改子进程，就把子进程先挂起
    3. 负荷调节的需要。有时候操作系统不够用了，把一些没啥用的进程暂时挂起
    4. 操作系统的需要。比如操作系统检查运行中的资源使用情况。
* 引入挂起原语操作后三个进程状态的转换
    1. 就绪挂起：活动就绪->静止就绪（挂起前叫活动，挂起后叫静止）
    2. 阻塞挂起：活动阻塞->静止阻塞
    3. 就绪激活：静止就绪->活动就绪（激活前叫静止，激活后叫活动）
    4. 阻塞激活：静止阻塞->活动阻塞

    引入挂起后的进程状态转换

    ![引入挂起后的进程状态转换](http://ww1.sinaimg.cn/large/006BhB5Ogy1fy8vlm7edjj30js0fbgmg.jpg)
#### 2.2.4 进程管理中的数据结构
* 操作系统中用于管理控制的数据结构

    分为内存表、设备表、文件表、进程表

    进程表一般就是指进程控制块PBC（进程实体的组成元素）
* 进程控制块PCB的作用

    作用：使一个在多道程序环境下 **不能独立运行的程序** （含数据）成为一个可以独立运行的基本单位，一个能与其他进程并发的进程。

    1. 作为独立运行单位的标志。
        
        创建进程时，为其建立一个进程PCB，结束进程时，系统回收PCB，系统时通过PCB来感知进程是否存在。
    2. 实现间断性运行方式。
        
        当进程因阻塞而暂停时，必须保留CPU的现场信息，再次被调度的时候要恢复这个信息。
    3. 提供进程管理所需要的信息。
    4. 提供进程调度所需要的信息。
    5. 实现与其他进程的同步与通信。
* 进程控制块PCB的信息
    
    进程控制块中包括几种信息
    1. 进程标识符
        * 内部标识（为系统方便）
        * 外部标识（为用户方便）
    2. 处理机状态
    3. 进程调度信息
        * 进程状态（就绪？or...）
        * 进程优先级
        * 进程调度所需要的其他信息
        * 事件（进程发生状态转变的原因）
    4. 进程控制信息
        * 程序和数据的地址
        * 进程同步和通信机制
        * 资源清单（所需要分配的全部资源，和已经分配的资源）
        * 链接指针（下一个进程的PCB地址）
* 进程控制块的组织方式
    
    一个系统中又很多的PCB，怎么组织
    1. 线性方式（线性表）
    2. 链接方式（链接成一个队列）
    3. 索引方式
### 2.3 进程控制
进程控制是进程管理中的最基本功能，包括创建进程、终止已完成的进程、转换状态。一般由OS的内核中的原语实现。
#### 2.3.1 操作系统内核
操作系统有多个层次组成，不同的功能设置在不同的层次。

内核：一些与硬件仅靠的模块、常用设备的驱动程序、进程调度的一些操作

内核就是安排紧靠硬件的软件层次中，常驻内存的一些模块（第一层软件扩充）

两种状态：
* 系统态

    较高的特权，能执行一切命令。
* 用户态

    特权较低

OS内核功能：
1. 支撑功能
    * 中断处理

        内核最基本的功能，操作系统赖以活动的基础
    * 时钟管理

        时间片
    * 原语操作

        原语：由若干条指令组成的，用于完成一定功能的一个过程。

        是原子操作（即要么全部执行，要么不执行），
2. 资源管理功能
    * 进程管理

        将其放在内核中。如进程调度、分派、创建、撤销、同步、通信。
    * 存储器管理

        内存分配、回收、保护、对换等放在内核，保证运行速度高。
    * 设备管理

        硬件的驱动程序、缓冲管理、设备分配。
#### 2.3.2 进程的创建
1. 进程的层次结构

    一个进程可以创建另外一个进程，被创建的进程就叫子进程，另外一个就是父进程

    子进程可以继承父进程的所有资源，撤销父进程的时候
2. 进程图
3. 引起创建进程的事件
    * 用户登录
    * 作业调度
    * 提供服务
    * 应用请求
4. 进程的创建
    1. 申请空白PCB。

        获取唯一标识，并从PCB集合索取一个空白的PCB
    2. 为新进程分配资源，包括各种物理资源和逻辑资源。

        比如内存、文件、I/O设备和CPU时间等。（可以从系统或父进程获取）

        所以这里新进程对资源的需求也要提前告知操作系统或者是父进程
    3. 初始化PCB。
        
        包括初始化标识信息、初始化处理机状态信息、初始化处理机控制信息
    4. 将新进程插入就绪队列
#### 2.3.3 进程终止
* 引起进程终止的事件
    * 正常结束

        在程序的最后通常会安排`Holt`指令。当程序执行这个指令时，产生一个 *中断* 通知系统本进程已经结束。
    * 异常结束

        * 越界错误：访问的存储区超过了进程分配的区域
        * 保护错：访问一个不允许访问的资源或文件，或者以不适当的方式区访问（比如写一个只读文件）
        * 非法指令：程序执行不存在的指令。
        * 特权指令错：用户进程试图去执行一条只允许OS执行的指令。
        * 运行超时：进程的时间超过了指定最大值
        * 等待超时：进程等待某时间的的时间，超过了规定最大值。
        * 算术运算错：执行被禁止的运算，比如除以0
        * I/O故障
    * 外界干预
        * 操作员和操作系统干预

            由于某种原因，例如发生死锁，操作员终止该进程。
        * 父进程请求

            子进程执行完成后，父进程可以请求终止该子进程。
        * 父进程终止

            父进程终止之后，它的所有子孙进程也将终止。
* 进程终止过程
    1. 根据PCB标识符，从PCB集合中检索出，并读出该进程状态
    2. 如果该进程 **处于执行状态** 应立即终止该进程的执行，**并置调度标志为真**，以便进程撤销后将处理机分配给其他进程。
    3. 若该进程还有子孙进程，还应将其所有子孙进程予以终止
    4. 将被终止的进程所拥有的全部资源，归还给操作系统或者父进程
    5. 撤销 PCB
#### 2.3.4进程的阻塞与唤醒
1. 引起进程阻塞和唤醒的事件
    * 向系统请求资源失败

        失败后即阻塞
    * 等待某种操作完成
    * 新数据尚未到达
    * 等待新任务的到达
2. 进程阻塞过程

    阻塞原语`block`

    改状态->PBC放入阻塞队列
3. 进程唤醒过程

    唤醒原语`wakeup`

    移出阻塞队列->改PBC状态->就绪队列
#### 2.3.5 进程的挂起与激活
1. 进程的挂起

    挂起原语`suspend`

    检测状态->改变状态（活动->静止）
2. 进程的激活过程

    激活原语`active`

    检查状态->改变状态（静止->活动
    ）

### 2.4 进程同步
#### 2.4.1 进程同步的基本概念
进程同步机制任务：

1. 两种形式的制约关系
    * 间接相互制约关系

        我和你一起用它（竞争）
    * 直接相互制约关系

        我要用你（协作）
2. 临界资源

    一次只允许一个进程使用，必须互斥访问。生产者-消费者问题。
3. 临界区
    
    每个进程访问临界资源的那段代码，在访问之前需要对其进程检查，看是否被用了。

    在临界区之间的代码称为进入区，后面那段取消标志的代码称为退出区。
4. 同步机制应遵循的规则
    * 空闲让进

        没人用的时候让你用
    * 忙则等待

        有人用的时候让你等
    * 有限等待
    * 让权等待
        
        当进程不能进入自己的临界区，立即释放处理机
#### 2.4.2 硬件同步机制
硬件提供锁测试的方式来判断有无进程在使用
1. 关中断

    关闭 中断 ，操作系统不响应中断操作
2. Test-and-Set指令（TS）
3. Swap指令
#### 2.4.3 信号量机制
信号量时OS提供管理的有效手段，可以代表可用资源实体的数量
* 整形信号量
* 记录型信号量

    一个进程玩完了，再让另外一个进程进
* AND型信号量

    要么不分配资源，要么就分配所需的所有资源
* 信号量集

    检测资源数量的下限，低于就不分配
#### 2.4.4 信号量的应用
* 利用信号量实现进程互斥
* 利用信号量实现前趋关系
#### 2.4.5 管程机制
* 定义

    将硬件软件资源看作数据结构

    将对这组数据结构的操作，定义为一组过程

    进程对共享资源的操作必须经过这组过程

    上面说的“数据结构”和“过程”合在一起就叫做管程

    所以管程由四个部分组成：1.名称2.代表共享资源的数据结构3.对这个数据结构的一组过程4. 对局部于共享数据设置初值的语句
* 条件变量

### 第三章
* 每一种调度算法必须牢记
* 选择调度方式和算法时应注意
    ```txt
    面向用户准则：周转时间短、相应快、截止时间的保证、优先权准则
    面向系统准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用
    ```
* 批处理系统的调度算法：短作业优先、优先权、高相应比优先、多级反馈队列调度算法
* 分时系统：时间片轮转法
* 实时系统的调度算法：最早截止时间优先（EDF）、最低松弛度优先（LLF）算法

* 比较FCFS和SPF
    * 相同点：两个都适用于
    * 不同点：FCFS有利于长作业（或进程）不利于短作业或进程。SPF相反

* 什么是死锁

* 产生死锁的条件