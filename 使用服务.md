# 服务
***
服务就是在后台使用，负责处理一些复杂逻辑的基本组件
* 给Button注册点击事件，点击后调用startService()方法启动服务
* 创建服务类 MyService
* 使用onBind绑定服务，实现服务和活动的通信
* 前台服务，弹窗(类似通知)
* 多线程服务
***
### 注册点击事件
```java
@Override
   protected void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       setContentView(R.layout.activity_main);
       Button start = ( Button ) findViewById( R.id.start_service ) ;
       Button stop = ( Button ) findViewById( R.id.stop_service ) ;
       start.setOnClickListener( this ) ;
       stop.setOnClickListener( this ) ;
```
```java
@Override
public void onClick ( View v ) {
    switch ( v.getId() ) {
        case R.id.start_service :
            Intent startIntent = new Intent ( MainActivity.this , MyService.class ) ;
            startService( startIntent ) ;//点击启动服务
            break;
        case R.id.stop_service :
            Intent stopIntent = new Intent ( MainActivity.this , MyService.class ) ;
            stopService ( stopIntent  ) ;//点击关闭服务
            break;
        default:
            break ;
    }
}
```
### 服务类
```java
public class MyService extends Service {


    public MyService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        throw new UnsupportedOperationExeption("Not yet imolemented") ;//这个方法后面会改写，现在暂时不管他。
    }

    @Override
    public void onCreate ( ) {
        super.onCreate();
        Log.d("Myservice", "onCreate executed");

    @Override
    public int onStartCommand( Intent intent , int flags , int startId ) {
        Log.d( "Myservice" , "onStartCommand executed" ) ;
        return super.onStartCommand( intent , flags , startId ) ;
    }

    @Override
    public void onDestroy ( ) {
        Log.d( "Myservice" , "onDestroy executed" ) ;
        super.onDestroy();
    }

}
```
几个方法分别在服务的各个阶段打印出相应的日志。这个时候已经基本实现了服务的使用了。
### 绑定服务，实现服务与活动之间的通信
上面的代码是打开活动，点击按钮服务就去工作了，我们不管他，也管不了他。如果需要让活动指定服务干什么，服务就去干什么就要用到onBind方法。
```java
    private DownloadBinder binder = new DownloadBinder() ;

    class DownloadBinder extends Binder {

        public void startDownload () {
            Log.d( "MyService" , "startDownload executed" ) ;
        }

        public int getProgress () {
            Log.d( "MyService" , "getProgress executed" ) ;
            return 0 ;
        }
```
```java
@Override
  public IBinder onBind(Intent intent) {
      // TODO: Return the communication channel to the service.
      return binder ;
  }
```
在MyService类中添加和修改以上代码，然后再在MainActivity中添加两个Button来控制绑定和解绑服务
```java
public MyService.DownloadBinder downloadBinder ;

private ServiceConnection connection = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
        downloadBinder = ( MyService.DownloadBinder ) iBinder ;
        downloadBinder.startDownload();
        downloadBinder.getProgress() ;
    }

    @Override
    public void onServiceDisconnected(ComponentName componentName) {

    }
} ;
```
在MainActivity中，先创建一个服务中新定义的DownloadBinder类的实例，然后重写onServiceDisconnected和onServiceConnected,分别在绑定和解绑的时候调用
```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    .
    .
    .
    Button bind = ( Button ) findViewById( R.id.bind ) ;
    Button unbind = ( Button ) findViewById( R.id.unbind ) ;
    bind.setOnClickListener( this ) ;
    unbind.setOnClickListener( this );
}
```
```java
public void onClick ( View v ) {
    switch ( v.getId() ) {
        .
        .
        .
        case R.id.bind :
            Intent bindIntent = new Intent ( this , MyService.class ) ;
            bindService( bindIntent , connection , BIND_AUTO_CREATE ) ;//绑定服务，BIND_AUTO_CREATE表示绑定后自动创建服务。
            break;
        case R.id.unbind :
            unbindService( connection ) ;//取消服务
        ...
}
```
### 加入前台服务功能
这里基本上和通知的弹窗功能一样，只是启动的时候使用的是startForeground()方法
```java
@Override
public void onCreate ( ) {
    super.onCreate();
    Log.d("Myservice", "onCreate executed");
    Intent intent = new Intent(this, MainActivity.class);
    PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);
    Notification notification = new NotificationCompat.Builder( this )
            .setContentTitle( "fuccccck send a message" )
            .setContentText( "nice to meet you")
            .setWhen( System.currentTimeMillis() )
            .setSmallIcon( R.mipmap.ic_launcher )
            .setLargeIcon(BitmapFactory.decodeResource( getResources() , R.mipmap.ic_launcher ) )
            .setContentIntent( pi )
            .build() ;
    startForeground( 1 , notification ) ;
}
```
### 多线程服务
因为一般的服务都是放在MainActivity的后台处理的，当处理的逻辑过于复杂，耗时过长，就会让app没有相应，所以每次使用服务时，开一个新的线程就能解决这个问题
